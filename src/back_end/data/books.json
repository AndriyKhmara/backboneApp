[{"id":1,"book":{"data":"<h3>Паттерн Builder</h3>\n\t\t\t<p><b><i>Название и классификация паттерна</i></b></p>\n\t\t\t<p>Строитель - паттерн, порождающий объекты.</p> \n\t\t\t<p><b><i>Назначение</i></b></p>\n\t\t\t<p>Отделяет конструирование сложного объекта от его представления, так что в результате одного и того же процесса конструирования могут получаться разные представления.</p>\n\t\t\t<p><b><i>Мотивация</i></b></p>\n\t\t\t<p>Программа, в которую заложена возможность распознавания и чтения документа в формате RTF (Rich Text Format), должна также «уметь» преобразовывать его во многие другие\n\t\t\t форматы, например в простой ASCII-текст или в представление, которое можно отобразить в виджете для ввода текста. Однако число вероятных преобразований заранее неизвестно.\n\t\t\t Поэтому должна быть обеспечена возможность без труда добавлять новый конвертор.</p>\n\t\t\t<p>Таким образом, нужно сконфигурировать класс RTFReader с помощью объекта Text Converter, который мог бы преобразовывать RTF в другой текстовый формат.\n\t\t\t При разборе документа в формате RTF класс RTFReader вызывает TextConverter для выполнения преобразования. Всякий раз, как RTFReader распознает лексему RTF \n\t\t\t (простой текст или управляющее слово), для ее преобразования объекту TextConverter посылается запрос. Объекты TextConverter отвечают как за преобразование \n\t\t\t данных, так и за представление лексемы в конкретном формате.</p>\n\t\t\t<p>Подклассы TextConverter специализируются на различных преобразованиях и форматах. Например, ASCIIConverter игнорирует запросы на преобразование чего бы то \n\t\t\tни было, кроме простого текста. С другой стороны, TeXConverter будет реализовывать все запросы для получения представления в формате редактора TJX, собирая\n\t\t\t по ходу необходимую информацию о стилях. A TextWidget Converter станет строить сложный объект пользовательского интерфейса, который позволит пользователю \n\t\t\t просматривать и редактировать текст.</p>\n\t\t\t \n\t\t\t<p>Класс каждого конвертора принимает механизм создания и сборки сложного объекта и скрывает его за абстрактным интерфейсом. Конвертор отделен от загрузчика,\n\t\t\t который отвечает за синтаксический разбор RTF-документа.</p>\n\t\t\t<p>В паттерне строитель абстрагированы все эти отношения. В нем любой класс конвертора называется <i>строителем</i>, а загрузчик - <i>распорядителем</i>. В применении к рассмотренному\n\t\t\t примеру строитель отделяет алгоритм интерпретации формата текста (то есть анализатор RTF-документов) от того, как создается и представляется документ в\n\t\t\t преобразованном формате. Это позволяет повторно использовать алгоритм разбора, реализованный в RTFReader, для создания разных текстовых представлений RTF-документов;\n\t\t\t достаточно передать в RTFReader различные подклассы класса Text Converter.</p>\n\t\t\t<p><b><i>Применимость</i></b></p>\n\t\t\t<p>Используйте паттерн строитель, когда:</p>\n\t\t\t  <ul>\n\t\t\t      <li> алгоритм создания сложного объекта не должен зависеть от того, из каких частей состоит объект и как они стыкуются между собой;</li>\n\t\t\t      <li> процесс конструирования должен обеспечивать различные представления конструируемого объекта.</li>\n\t\t\t  </ul>\n\t\t\t<p><b><i>Структура</i></b></p>\n\t\t\t \n\t\t\t  \n\n\t\t\t<p><b><i>Участники</i></b></p>\n\t\t\t  <ul>\n\t\t\t      <li><b>Builder</b> (TextConverter) - строитель:\n\t\t\t          <ul>\n\t\t\t              <li>-\tзадает абстрактный интерфейс для создания частей объекта Product;</li>\n\t\t\t          </ul></li>\n\t\t\t      <li>ConcreteBuilder(ASCIIConverter,TeXConverter,TextWidgetConverter)- конкретный строитель:\n\t\t\t          <ul>\n\t\t\t             <li>-\tконструирует и собирает вместе части продукта посредством реализации интерфейса Builder;</li>\n\t\t\t             <li>-\tопределяет создаваемое представление и следит за ним;</li>\n\t\t\t             <li>-\tпредоставляет интерфейс для доступа к продукту (например, GetASCI IText, GetT extWidget);</li>\n\t\t\t          </ul></li>\n\t\t\t      <li> <b>Director</b> (RTFReader) - распорядитель:\n\t\t\t        <ul>\n\t\t\t            <li>-\tконструирует объект, пользуясь интерфейсом Builder; </li>\n\t\t\t        </ul></li>\n\t\t\t      <li><b>Product</b> (ASCIIText, TeXText, TextWidget) - продукт:\n\t\t\t        <ul>\n\t\t\t            <li>-\tпредставляет сложный конструируемый объект. ConcreteBuilder строит внутреннее представление продукта и определяет процесс его сборки;</li>\n\t\t\t            <li>-\tвключает классы, которые определяют составные части, в том числе ин-терфейсы для сборки конечного результата из частей.</li>\n\t\t\t        </ul></li>\n\t\t\t  </ul>\n\t\t\t <p><b><i>Отношения</i></b></p>\n\t\t\t  <ul>\n\t\t\t      <li> клиент создает объект-распорядитель Director и конфигурирует его нужным объектом-строителем Builder;</li>\n\t\t\t      <li> распорядитель уведомляет строителя о том, что нужно построить очередную часть продукта;</li>\n\t\t\t      <li> строитель обрабатывает запросы распорядителя и добавляет новые части к продукту;</li>\n\t\t\t      <li> клиент забирает продукт у строителя.</li>\n\t\t\t  </ul>\n\t\t\t<p>Следующая диаграмма взаимодействий иллюстрирует взаимоотношения строителя и распорядителя с клиентом.</p>\n\n\t\t\t\n\t\t\t<p><b><i>Результаты</i></b></p>\n\t\t\t<p>Плюсы и минусы паттерна строитель и его применения:</p>\n\t\t\t  <ul>\n\t\t\t      <li> <i>позволяет изменять внутреннее представление продукта</i>. Объект Builder предоставляет распорядителю абстрактный интерфейс для конструирования продукта, за которым\n\t\t\t      он может скрыть представление и внутреннюю структуру продукта, а также процесс его сборки. Поскольку продукт конструируется через абстрактный интерфейс,\n\t\t\t      то для изменения внутреннего представления достаточно всего лишь определить новый вид строителя;</li>\n\t\t\t      <li> <i>изолирует код, реализующий конструирование и представление</i>. Паттерн строитель улучшает модульность, инкапсулируя способ конструирования и представления\n\t\t\t      сложного объекта. Клиентам ничего не надо знать о классах, определяющих внутреннюю структуру продукта, они отсутствуют в интерфейсе строителя. \n\t\t\t      <p>Каждый конкретный строитель ConcreteBuilder содержит весь код, необходимый для создания и сборки конкретного вида продукта. Код пишется только один раз, \n\t\t\t      после чего разные распорядители могут использовать его повторно для построения вариантов продукта из одних и тех же частей. В примере с RTF-документом мы могли\n\t\t\t      бы определить загрузчик для формата, отличного от RTF, скажем, SGMLReader, и воспользоваться теми же самыми классами TextConverters\n\t\t\t      для генерирования представлений SGML-документов в виде ASCII-текста, ТеХ-текста или текстового виджета;</p></li>\n\t\t\t      <li> <i>дает более тонкий контроль над процессом конструирования</i>. В отличие от порождающих паттернов, которые сразу конструируют весь объект целиком, \n\t\t\t      строитель делает это шаг за шагом под управлением распорядителя. И лишь когда продукт завершен, распорядитель забирает его у строителя.\n\t\t\t      Поэтому интерфейс строителя в большей степени отражает процесс конструирования продукта, нежели другие порождающие паттерны. \n\t\t\t      Это позволяет обеспечить более тонкий контроль над процессом конструирования, а значит, и над внутренней структурой готового продукта.</li>\n\t\t\t  </ul>\n\t\t\t<p><b><i>Реализация</i></b></p>\n\t\t\t<p>Обычно существует абстрактный класс Builder, в котором определены операции для каждого компонента, который распорядитель может «попросить» создать.\n\t\t\t По умолчанию эти операции ничего не делают. Но в классе конкретного строите¬ля ConcreteBuilder они замещены для тех компонентов, в создании которых он принимает участие.</p>\n\t\t\t<p>Вот еще некоторые достойные внимания вопросы реализации:</p>\n\t\t\t  <ul>\n\t\t\t    <li> <i>интерфейс сборки и конструирования</i>. Строители конструируют свои продукты шаг за шагом. Поэтому интерфейс класса Builder должен быть достаточно общим, \n\t\t\t    чтобы обеспечить конструирование при любом виде конкретного строителя.\n\t\t\t    <p>Ключевой вопрос проектирования связан с выбором модели процесса кон-струирования и сборки. Обычно бывает достаточно модели, в которой результаты выполнения\n\t\t\t    запросов на конструирование просто добавляются к продукту. В примере с RTF-документами строитель преобразует и добавляет очередную лексему к уже конвертированному тексту.</p>\n\t\t\t    <p>Но иногда может потребоваться доступ к частям сконструированного к данному моменту продукта. В примере с лабиринтом, который будет описан в разделе «Пример кода»,\n\t\t\t    интерфейс класса MazeBui Ider позволяет добавлять дверь между уже существующими комнатами. Другим примером являются древовидные структуры, скажем, деревья\n\t\t\t    синтаксического разбора, которые строятся снизу вверх. В этом случае строитель должен был бы вернуть узлы-потомки распорядителю, который затем передал\n\t\t\t    бы их назад строителю, чтобы тот мог построить родительские узлы.</p></li>\n\t\t\t    <li> <i>почему нет абстрактного класса для продуктов</i>. В типичном случае продукты, изготавливаемые различными строителями, имеют настолько разные представления,\n\t\t\t    что изобретение для них общего родительского класса ничего не дает. В примере с RTF-документами трудно представить себе общий интерфейс у объектов ASCIIText \n\t\t\t    и TextWidget, да он и не нужен. Поскольку клиент обычно конфигурирует распорядителя подходящим конкретным строителем, то, надо полагать, ему известно,\n\t\t\t    какой именно подкласс класса Builder используется и как нужно обращаться с произведенными продуктами;</li>\n\t\t\t    <li> <i>пустые методы класса Builder no умолчанию</i>. В C++ методы строителя намеренно не объявлены чисто виртуальными функциями-членами. Вместо этого они определены\n\t\t\t    как пустые функции, что позволяет подклассу замещать только те операции, в которых он заинтересован.</li>\n\t\t\t  </ul>\n\t\t\t<p><b><i>Пример кода</i></b></p>\n\t\t\t<p>Определим вариант функции-члена CreateMaze, которая принимает в качестве аргумента строитель, принадлежащий классу MazeBuilder.</p>\n\t\t\t<p>Класс MazeBuilder определяет следующий интерфейс для построения лабиринтов:</p>\n\t\t\t<pre>\n\t\t\t  class MazeBuilder {\n\t\t\t  public:\n\t\t\t      virtual void BuildMaze() { }\n\t\t\t      virtual void BuildRoom(int room) { }\n\t\t\t      virtual void BuildDoor(int roomFrom, int roomTo) { }\n\t\t\t      \n\t\t\t      virtual Maze* GetMaze() { return 0; }\n\t\t\t  protected:\n\t\t\t      MazeBuilder();\n\t\t\t  };\n\t\t\t </pre>\n\t\t\t<p>Этот интерфейс позволяет создавать три вещи: лабиринт, комнату с конкретным номером, двери между пронумерованными комнатами. Операция GetMaze возвращает лабиринт клиенту.\n\t\t\t В подклассах MazeBui Ider данная операция переопределяется для возврата реально созданного лабиринта.</p>\n\t\t\t<p>Все операции построения лабиринта в классе MazeBuilder по умолчанию ничего не делают. Но они не объявлены исключительно виртуальными, чтобы в производных классах\n\t\t\t можно было замещать лишь часть методов.</p>\n\t\t\t<p>Имея интерфейс MazeBuilder, можно изменить функцию-член CreateMaze, чтобы она принимала строитель в качестве параметра:</p>\n\t\t\t<pre>\n\t\t\t  Maze* MazeGame::CreateMaze (MazeBuilder& builder) {\n\t\t\t      builder.BuildMaze();\n\t\t\t      \n\t\t\t      builder.BuiIdRoom(l); \n\t\t\t      builder.BuiIdRoom(2);\n\t\t\t      builder.BuildDoor(1, 2);\n\t\t\t      \n\t\t\t      return builder.GetMaze();\n\t\t\t  }\n\t\t\t </pre>\n\t\t\t<p>Сравните эту версию CreateMaze с первоначальной. Обратите внимание, как строитель скрывает внутреннее представление лабиринта, то есть классы комнат,\n\t\t\t дверей и стен, и как эти части собираются вместе для завершения построения лабиринта. Кто-то, может, и догадается, что для представления комнат и дверей есть\n\t\t\t особые классы, но относительно стен нет даже намека. За счет этого становится проще модифицировать способ представления лабиринта, поскольку ни одного из клиентов\n\t\t\t MazeBuilder изменять не надо.</p>\n\t\t\t<p>Как и другие порождающие паттерны, строитель инкапсулирует способ создания объектов; в данном случае с помощью интерфейса, определенного классом MazeBuilder.\n\t\t\t Это означает, что MazeBuilder можно повторно использовать для построения лабиринтов разных видов. В качестве примера приведем функцию GreateComplexMaze:</p>\n\t\t\t<pre>\n\t\t\t  Maze* MazeGame::CreateComplexMaze (MazeBuilder& builder) {\n\t\t\t      builder.BuildRoom(l);\n\t\t\t      \n\t\t\t      builder.BuildRoom(lOOl);\n\t\t\t      \n\t\t\t      return builder.GetMazeO ;\n\t\t\t </pre>     \n\t\t\t<p>Обратите внимание, что MazeBuilder не создает лабиринты самостоятельно, его основная цель - просто определить интерфейс для создания лабиринтов.\n\t\t\t Пустые реализации в этом интерфейсе определены только для удобства. Реальную работу выполняют подклассы MazeBuilder.</p>\n\t\t\t<p>Подкласс StandardMazeBuilder содержит реализацию построения простых лабиринтов. Чтобы следить за процессом создания, используется переменная _currentMaze:</p>\n\t\t\t<pre>\n\t\t\t  class StandardMazeBuilder : public MazeBuilder {\n\t\t\t  public:\n\t\t\t      StandardMazeBuilder();\n\t\t\t      \n\t\t\t      virtual void BuildMazeO; \n\t\t\t      virtual void BuildRoom(int);\n\t\t\t      virtual void BuildDoor(int, int);\n\t\t\t      virtual Maze* GetMazef);\n\t\t\t  private:\n\t\t\t      Direction CommonWall(Room*, Room*);\n\t\t\t      Maze* _currentMaze;\n\t\t\t  };\n\t\t\t  </pre>\n\t\t\t<p>CommonWall (общая стена) - это вспомогательная операция, которая определяет направление общей для двух комнат стены.</p>\n\t\t\t<p>Конструктор StandardMazeBuilder просто инициализирует „currentMaze:</p>\n\t\t\t<pre>\n\t\t\t  StandardMazeBuilder::StandardMazeBuilder ()\t{\n\t\t\t      _currentMaze = 0;\n\t\t\t} </pre>\n\t\t\t<p>BuildMaze инстанцирует объект класса Maze, который будет собираться другими операциями и, в конце концов, возвратится клиенту (с помощью GetMaze):</p>\n\t\t\t<pre>\n\t\t\t  void StandardMazeBuilder: : BuildMaze () {\n\t\t\t      _currentMaze = new Maze;\n\t\t\t  }\n\t\t\t  \n\t\t\t  Maze* StandardMazeBuilder::GetMaze ()\t{\n\t\t\t      return _currentMaze;\n\t\t\t  }\n\t\t\t  </pre>\n\t\t\t<p><b>Операция BuildRoom создает комнату и строит вокруг нее стены:</b></p>\n\t\t\t<pre>\n\t\t\t  void StandardMazeBuilder::BuildRoom (int n) { \n\t\t\t      if (!_currentMaze->RoomNo(n)) {\n\t\t\t        Room* room = new Room(n);\n\t\t\t        _currentMaze->AddRoom(room);\n\t\t\t        \n\t\t\t       room->SetSide(North, new Wall);\n\t\t\t       room->SetSide(South, new Wall);\n\t\t\t       room->SetSide(East, new Wall);\n\t\t\t       room->SetSide(West, new Wall);\n\t\t\t  }\n\t\t\t</pre>\n\t\t\t<p>Чтобы построить дверь между двумя комнатами, StandardMazeBuilder находит обе комнаты в лабиринте и их общую стену:</p>\n\t\t\t<pre>\n\t\t\t  void StandardMazeBuilder : rBuildDoor (int nl , int n2 ) {\n\t\t\t       Room* rl = _currentMaze->RoomNo (nl) ;\n\t\t\t       Room* r2 = _currentMaze->RoomNo (n2) ;\n\t\t\t       Door* d = new Door(rl, r2) ;\n\t\t\t       \n\t\t\t      rl->SetSide(CommonWall(rl,r2) , d) ; \n\t\t\t      r2->SetSide(CommonWall(r2,rl) , d) ;\n\t\t\t  }\n\t\t\t</pre>\n\t\t\t<p>Теперь для создания лабиринта клиенты могут использовать Great eMaze в сочетании с StandardMazeBuilder:</p>\n\t\t\t<pre>\n\t\t\t  Maze* maze;\n\t\t\t  MazeGame game;\n\t\t\t  StandardMazeBuilder builder;\n\t\t\t  \n\t\t\t  game. CreateMaze (builder);\n\t\t\t  maze = builder. GetMaze ( );\n\t\t\t </pre>\n\t\t\t<p>Мы могли бы поместить все операции класса StandardMazeBuilder в класс Maze и позволить каждому лабиринту строить самого себя. Но чем меньше класс Maze,\n\t\t\t тем проще он для понимания и модификации, a StandardMazeBuilder легко отделяется от Maze. Еще важнее то, что разделение этих двух классов позволяет имет\n\t\t\t множество разновидностей класса MazeBuilder, в каждом из которых есть собственные классы для комнат, дверей и стен.</p>\n\n\t\t\t<p>Необычным вариантом MazeBuiIder является класс Count ingMazeBuiIder. Этот строитель вообще не создает никакого лабиринта, он лишь подсчитывает число\n\t\t\t компонентов разного вида, которые могли бы быть созданы:</p>\n\t\t\t<pre>\n\t\t\t  class CountingMazeBuilder : public MazeBuilder {\n\t\t\t  public:\n\t\t\t      CountingMazeBuilderO ;\n\t\t\t      \n\t\t\t     virtual void BuildMazeO;\n\t\t\t     virtual void BuildRoom(int);\n\t\t\t     virtual void BuildDoor (int, int); \n\t\t\t     virtual void AddWall(int, Direction);\n\t\t\t     \n\t\t\t     void GetCounts (int&, int&) const;\n\t\t\t  private:\n\t\t\t     int _doors,- \n\t\t\t     int _rooms;\n\t\t\t};\n\t\t\t</pre>\n\t\t\t<p>Конструктор инициализирует счетчики, а замещенные операции класса MazeBuilder увеличивают их:</p>\n\t\t\t<pre>\n\t\t\t  CountingMazeBuilder: : CountingMazeBuilder () {\n\t\t\t    _rooms = _doors = 0;\n\t\t\t  }\n\t\t\t  void CountingMazeBuilder::BuildRoom (int) {\n\t\t\t    _rooms++;\n\t\t\t  }\n\t\t\t  void CountingMazeBuilder: .-BuildDoor (int, int) {\n\t\t\t    _doors++;\n\t\t\t  }\n\t\t\t  void CountingMazeBuilder::GetCounts ( int& rooms, int& doors\n\t\t\t  ) const {\n\t\t\t    rooms = _rooms;\n\t\t\t    doors = _doors;\n\t\t\t }\n\t\t\t </pre>\n\t\t\t<p><b>Вот как клиент мог бы использовать класс</b> CountingMazeBuilder:</p>\n\t\t\t<pre>\n\t\t\t  int rooms, doors;\n\t\t\t  MazeGame game;\n\t\t\t  CountingMazeBuilder builder;\n\t\t\t  \n\t\t\t  game.CreateMaze(builder); \n\t\t\t  builder.GetCounts(rooms, doors);\n\t\t\t  cout « \"В лабиринте есть \n\n\t\t\t  « rooms « \" комнат и \"\n\t\t\t  « doors «\t\"\tдверей\" « endl;\n\t\t\t</pre>\n\t\t\t<p><b><i>Известные применения</i></b></p>\n\t\t\t<p>Приложение для конвертирования из формата RTF взято из библиотеки ЕТ++ [WGM88]. В ней используется строитель для обработки текста, хранящегося в таком формате.</p>\n\t\t\t<p>Паттерн строитель широко применяется в языке Smalltalk-80 [РагЭО]:</p>\n\t\t\t  <ul>\n\t\t\t      <li> класс Parser в подсистеме компиляции - это распорядитель, которому в качестве аргумента передается объект ProgramNodeBuilder. Объект класса Parser извещает объект \n\t\t\t      ProgramNodeBuilder после распознава¬ния каждой ситаксической конструкции. После завершения синтаксического разбора Parser обращается к строителю за созданным\n\t\t\t      деревом разбора и возвращает его клиенту;</li>\n\t\t\t      <li> Class Builder- это строитель, которым пользуются все классы для создания своих подклассов. В данном случае этот класс выступает одновременно в качестве\n\t\t\t      распорядителя и продукта;</li>\n\t\t\t      <li> ByteCodeStream- это строитель, который создает откомпилированный метод в виде массива байтов. ByteCodeStream является примером нестандартного применения паттерна\n\t\t\t      строитель, поскольку сложный объект представляется как массив байтов, а не как обычный объект Smalltalk. Но интерфейс к ByteCodeStream \n\t\t\t      типичен для строителя, и этот класс легко можно было бы заменить другим, который представляет программу в виде составного объекта.</li>\n\t\t\t  </ul>\n\t\t\t<p><b><i>Родственные паттерны</i></b></p>\n\t\t\t<p>Абстрактная фабрика похожа на строитель в том смысле, что может конструировать сложные объекты. Основное различие между ними в том, что строитель делает \n\t\t\tакцент на пошаговом конструировании объекта, а абстрактная фабрика - на создании семейств объектов (простых или сложных). Строитель возвращает продукт \n\t\t\tна последнем шаге, тогда как с точки зрения абстрактной фабрики продукт возвращается немедленно.</p>\n\t\t\t<p>Паттерн компоновщик - это то, что часто создает строитель.</p>\n\t"}},{"id":2,"book":{"data":"<h3>Паттерн Factory Method</h3>\n\t\t\t<p><b><i>Название и классификация паттерна</i></b></p>\n\t\t\t<p>Фабричный метод - паттерн, порождающий классы.</p>\n\t\t\t<p><b><i>Назначение</i></b></p>\n\t\t\t<p>Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, какой класс инстанцировать. Фабричный метод позволяет классу делегировать \n\t\t\tинстанцирование подклассам.</p>\n\t\t\t<p><b><i>Известен также под именем</i></b></p>\n\t\t\t<p>Virtual Constructor (виртуальный конструктор).</p>\n\t\t\t<p><b><i>Мотивация</i></b></p>\n\t\t\t<p>Каркасы пользуются абстрактными классами для определения и поддержания отношений между объектами. Кроме того, каркас часто отвечает за создание самих объектов.</p>\n\t\t\t<p>Рассмотрим каркас для приложений, способных представлять пользователю сразу несколько документов. Две основных абстракции в таком каркасе - \n\t\t\tэто классы Application и Document. Оба класса абстрактные, поэтому клиенты должны порождать от них подклассы для создания специфичных для приложения \n\t\t\tреализаций. Например, чтобы создать приложение для рисования, мы определим классы DrawingApplication и DrawingDocument. Класс Application отвечает \n\t\t\tза управление документами и создает их по мере необходимости, допустим, когда пользователь выбирает из меню пункт <b>Open</b> (открыть) или <b>New</b> (создать).</p>\n\t\t\t<p>Поскольку решение о том, какой подкласс класса Document инстанцировать, зависит от приложения, то Application не может «предсказать», что именно понадобится. \n\t\t\tЭтому классу известно лишь, когда нужно инстанцировать новый документ, а не какой документ создать. Возникает дилемма: каркас должен инстанцировать классы,\n\t\t\t но «знает» он лишь об абстрактных классах, которые инстанцировать нельзя.</p>\n\t\t\t<p>Решение предлагает паттерн фабричный метод. В нем инкапсулируется информация о том, какой подкласс класса Document создать, и это знание выводится за пределы каркаса.</p>\n\t\t\t\n\t\t\t<p>Подклассы класса Application переопределяют абстрактную операцию CreateDocument таким образом, чтобы она возвращала подходящий подкласс класса Document. \n\t\t\tКак только подкласс Application инстанцирован, он может инстанцировать специфические для приложения документы, ничего не зная об их классах.\n\t\t\t Операцию CreateDocument мы называем <i>фабричным методом</i>, поскольку она отвечает за «изготовление» объекта.</p>\n\t\t\t<p><b><i>Применимость</i></b></p>\n\t\t\t<p>Используйте паттерн фабричный метод, когда:</p>\n\t\t\t  <ul>\n\t\t\t    <li>классу заранее неизвестно, объекты каких классов ему нужно создавать;</li>\n\t\t\t    <li>класс спроектирован так, чтобы объекты, которые он создает, специфицировались подклассами;</li>\n\t\t\t    <li>класс делегирует свои обязанности одному из нескольких вспомогательных подклассов,\n\t\t\t    и вы планируете локализовать знание о том, какой класс при¬нимает эти обязанности на себя.</li>\n\t\t\t  </ul>\n\t\t\t<p><b><i>Структура</i></b></p>\n\t\t\t\n\t\t\t<p><b><i>Участники</i></b></p>\n\t\t\t  <ul>\n\t\t\t      <li><b>Product</b> (Document) - продукт:\n\t\t\t          <ul>\n\t\t\t              <li>-\tопределяет интерфейс объектов, создаваемых фабричным методом;</li>\n\t\t\t          </ul> </li>   \n\t\t\t      <li><b>ConcreteProduct</b> (MyDocument) - конкретный продукт:\n\t\t\t          <ul>\n\t\t\t              <li>-\tреализует интерфейс Product;</li>\n\t\t\t          </ul></li>\n\t\t\t      <li><b>Creator </b>(Application) - создатель:\n\t\t\t          <ul>\n\t\t\t            <li>-\tобъявляет фабричный метод, возвращающий объект типа Product. Creator может также определять реализацию по умолчанию фабричного метода, который \n\t\t\t            возвращает объект ConcreteProduct;</li>\n\t\t\t            <li>-\tможет вызывать фабричный метод для создания объекта Product.\n\t\t\t            </ul></li>\n\t\t\t            <li><b>ConcreteCreator</b> (MyApplication) - конкретный создатель:\n\t\t\t              <ul>\n\t\t\t            <li>-\tзамещает фабричный метод, возвращающий объект ConcreteProduct.</li>\n\t\t\t          </ul></li>\n\t\t\t  </ul>\n\t\t\t<p><b><i>Отношения</i></b></p>\n\t\t\t<p>Создатель «полагается» на свои подклассы в определении фабричного метода, который будет возвращать экземпляр подходящего конкретного продукта.</p>\n\t\t\t<p><b><i>Результаты</i></b></p>\n\t\t\t<p>Фабричные методы избавляют проектировщика от необходимости встраивать в код зависящие от приложения классы. Код имеет дело только с интерфейсом класса Product, \n\t\t\tпоэтому он может работать с любыми определенными пользователями классами конкретных продуктов.</p>\n\t\t\t<p>Потенциальный недостаток фабричного метода состоит в том, что клиентам, возможно, придется создавать подкласс класса Creator для создания лишь одного\n\t\t\t объекта ConcreteProduct. Порождение подклассов оправдано, если клиенту так или иначе приходится создавать подклассы Creator, в противном случае клиенту \n\t\t\t придется иметь дело с дополнительным уровнем подклассов.</p>\n\t\t\t<p>А вот еще два последствия применения паттерна срабричный метод:</p>\n\t\t\t  <ul>\n\t\t\t      <li> <i>предоставляет подклассам операции-зацепки (hooks)</i>. Создание объектов внутри класса с помощью фабричного метода всегда оказывается более гибким решением, \n\t\t\t      чем непосредственное создание. Фабричный метод создает в подклассах операции-зацепки для предоставления расширенной версии объекта.\n\t\t\t      <p>В примере с документом класс Document мог бы определить фабричный метод CreateFileDialog, который создает диалоговое окно для выбора файла существующего документа. \n\t\t\t      Подкласс этого класса мог бы определить специализированное для приложения диалоговое окно, заместив этот фабричный метод. В данном случае фабричный метод не является\n\t\t\t      абстрактным, а содержит разумную реализацию по умолчанию;</p></li>\n\t\t\t      <li><i>соединяет параллельные иерархии</i>. В примерах, которые мы рассматривали до сих пор, фабричные методы вызывались только создателем. Но это совершенно необязательно:\n\t\t\t      клиенты тоже могут применять фабричные методы, особенно при наличии параллельных иерархий классов.\n\t\t\t      <p>Параллельные иерархии возникают в случае, когда класс делегирует часть своих обязанностей другому классу, не являющемуся производным от него. Рассмотрим, например,\n\t\t\t      графические фигуры, которыми можно манипулировать интерактивно: растягивать, двигать или вращать с помощью мыши. Реализация таких взаимодействий с пользователем \n\t\t\t      - не всегда простое дело. Часто приходится сохранять и обновлять информацию о текущем состоянии манипуляций. Но это состояние нужно только во время самой манипуляции,\n\t\t\t      поэтому помещать его в объект, представляющий фигуру, не следует. К тому же фигуры ведут себя по-разному, когда пользователь манипулирует ими. Например, растягивание \n\t\t\t      отрезка может сводиться к изменению положения концевой точки, а растягивание текста - к изменению междустрочных интервалов.</p>\n\t\t\t      <p>При таких ограничениях лучше использовать отдельный объект-манипулятор Manipulator, который реализует взаимодействие и контролирует его текущее состояние. \n\t\t\t      У разных фигур будут разные манипуляторы, являющиеся подклассом Manipulator. Получающаяся иерархия класса Manipulator параллельна (по крайней мере, частично)\n\t\t\t      иерархии класса Figure.</p>\n\t\t\t      <p>Класс Figure предоставляет фабричный метод CreateManipulator, который позволяет клиентам создавать соответствующий фигуре манипулятор. Подклассы Figure \n\t\t\t      замещают этот метод так, чтобы он возвращал подходящий для них подкласс Manipulator. Вместо этого класс Figure может реализовать CreateManipulator так,\n\t\t\t      что он будет возвращать экземпляр класса Manipulator по умолчанию, а подклассы Figure могут наследовать это умолчание. Те классы фигур, которые функционируют\n\t\t\t      по описанному принципу, не нуждаются в специальном манипуляторе, поэтому иерархии параллельны только отчасти.</p></li>\n\t\t\t</ul>\n\t\t\t\n\t\t\t<p>Обратите внимание, как фабричный метод определяет связь между обеими иерархиями классов. В нем локализуется знание о том, какие классы способны работать совместно.</p>\n\t\t\t<p><b><i>Реализация</i></b></p>\n\t\t\t<p>Рассмотрим следующие вопросы, возникающие при использовании паттерна фабричный метод:</p>\n\t\t\t    <ul>\n\t\t\t        <li>две основных разновидности паттерна. Во-первых, это случай, когда класс С г eat or'является абстрактным и не содержит реализации объявленного \n\t\t\t        в нем фабричного метода. Вторая возможность: Creator - конкретный класс, в котором по умолчанию есть реализация фабричного метода.\n\t\t\t        Редко, но встречается и абстрактный класс, имеющий реализацию по умолчанию; В первом случае для определения реализации необходимы подклассы, поскольку\n\t\t\t        никакого разумного умолчания не существует. При этом обходится проблема, связанная с необходимостью инстанцировать заранее неизвестные классы. \n\t\t\t        Во втором случае конкретный класс Creator использует фабричный метод, главным образом ради повышения гибкости. Выполняется правило:\n\t\t\t        «Создавай объекты в отдельной операции, чтобы подклассы могли подменить способ их создания». Соблюдение этого правила гарантирует, что авторы подклассов\n\t\t\t        смогут при необходимости изменить класс объектов, инстанцируемых их родителем;</li>\n\t\t\t        <li>параметризованные фабричные методы. Это еще один вариант паттерна, который позволяет фабричному методу создавать разные виды продуктов. Фабричному \n\t\t\t        методу передается параметр, который идентифицирует вид создаваемого объекта. Все объекты, получающиеся с помощью фабричного метода, разделяют\n\t\t\t        общий интерфейс Product. В примере с документами класс Application может поддерживать разные виды документов. Вы передаете методу CreateDocument\n\t\t\t        лишний параметр, который и определяет, документ какого вида нужно создать.\n\t\t\t        <p>В каркасе Unidraw для создания графических редакторов [VL90] используется именно этот подход для реконструкции объектов', сохраненных на диске. Unidraw\n\t\t\t        определяет класс Creator с фабричным методом Create, которому в качестве аргумента передается идентификатор класса, определяющий, какой класс \n\t\t\t        инстанцировать. Когда Unidraw сохраняет объект на диске, он сначала записывает идентификатор класса, а затем его переменные экземпляра. При реконструкции объекта \n\t\t\t        сначала считывается идентификатор класса. Прочитав идентификатор класса, каркас вызывает операцию Create, передавая ей этот идентификатор\n\t\t\t        как параметр. Create ищет конструктор соответствующего класса и с его помощью производит инстанцирование. И наконец, Create вызывает операцию Read \n\t\t\t        созданного объекта, которая считывает с диска остальную информацию и инициализирует переменные экземпляра.</p>\n\t\t\t        <p>Параметризованный фабричный метод в общем случае имеет следующий вид (здесь My Product и Your Product - подклассы Product):</p>\n\t\t\t    <pre>\n\t\t\t      class Creator { public:\n\t\t\t          virtual Product* Create(Productld);\n\t\t\t      };\n\t\t\t        Product* Creator::Create (Productld id) { \n\t\t\t            if (id == MINE) return new MyProduct; \n\t\t\t            if (id == YOURS) return new YourProduct;\n\t\t\t            // выполнить для всех остальных продуктов...\n\t\t\t            return 0;\n\t\t\t        }\n\t\t\t    </pre>\n\t\t\t        <p>Замещение параметризованного фабричного метода позволяет легко и избирательно расширить или заменить продукты, которые изготавливает создатель.\n\t\t\t        Можно завести новые идентификаторы для новых видов продуктов или ассоциировать существующие идентификаторы с другими продуктами. Например,\n\t\t\t        подкласс MyCreator мог бы переставить местами MyProduct и YourProduct для поддержки третьего подкласса Their Product:</p>\n\t\t\t    <pre>\n\t\t\t      Product* MyCreator::Create (Productld id) { \n\t\t\t          if (id == YOURS) return new MyProduct;\n\t\t\t          if (id == MINE) return new YourProduct;\n\t\t\t          // N.B.: YOURS и MINE переставлены\n\t\t\t          if (id == THEIRS) return new TheirProduct;\n\t\t\t      \n\t\t\t          return Creator::Create(id); // вызывается, если больше ничего\n\t\t\t                                      //не осталось\n\t\t\t      }\n\t\t\t    </pre>\n\t\t\t      <p>Обратите внимание, что в самом конце операция вызывает метод Create родительского класса. Так делается постольку, поскольку MyCreator: : Create\n\t\t\t        обрабатывает только продукты YOURS, MINE и THEIRS иначе, чем родительский класс. Поэтому MyCreator расширяет некоторые виды создаваемых продуктов,\n\t\t\t        а создание остальных поручает своему родительскому классу;</p></li>\n\t\t\t      <li><i>языково-зависимые вариации и проблемы</i>. В разных языках возникают собственные интересные варианты и некоторые нюансы.\n\t\t\t      <p>Так, в программах на Smalltalk часто используется метод, который возвращает класс подлежащего инстанцированию объекта. Фабричный метод Creator может воспользоваться\n\t\t\t      возвращенным значением для создания продукта, a ConcreteCreator может сохранить или даже вычислить это значение. В результате привязка к типу конкретного инстанцируемого\n\t\t\t      продукта ConcreteProduct происходит еще позже.</p>\n\t\t\t      <p>В версии примера Document на языке Smalltalk допустимо определить метод documentClass в классе Application. Данный метод возвращает подходящий класс Document для\n\t\t\t        инстанцирования документов. Реализация метода documentClass в классе MyApplication возвращает класс MyDocument. Таким образом, в классе Application мы имеем\n\t\t\t  <pre>\n\t\t\t      clientMethod\n\t\t\t          document : = self documentClass new.\n\t\t\t          \n\t\t\t      documentClass\n\t\t\t          self subclassResponsibility\n\t\t\t  </pre>\n\t\t\t    <p>а в классе MyApplication —</p>\n\t\t\t  <pre>\n\t\t\t      documentClass\n\t\t\t          ^ MyDocument\n\t\t\t  </pre>\n\t\t\t      <p>что возвращает класс MyDocument, который должно инстанцировать приложение Application.</p>\n\t\t\t      <p>Еще более гибкий подход, родственный параметризованным фабричным методам, заключается в том, чтобы сохранить подлежащий созданию класс в качестве переменной \n\t\t\t      класса Application. В таком случае для изменения продукта не нужно будет порождать подкласс Application.</p>\n\t\t\t      <p>В C++ фабричные методы всегда являются виртуальными функциями, а часто даже исключительно виртуальными. Нужно быть осторожней и не вызывать фабричные\n\t\t\t      методы в конструкторе класса Creator: в этот момент фабричный метод в производном классе ConcreteCreator еще недоступен. Обойти такую сложность можно, \n\t\t\t      если получать доступ к продуктам только с помощью функций доступа, создающих продукт по запросу. Вместо того чтобы создавать конкретный продукт, \n\t\t\t      конструктор просто инициализирует его нулем. Функция доступа возвращает продукт, но сначала проверяет, что он существует. Если это не так, функция \n\t\t\t      доступа создает продукт. Подобную технику часто называют отложенной инициализацией. В следующем примере показана типичная реализация:</p>\n\t\t\t  <pre>\n\t\t\t      class Creator { \n\t\t\t      public:\n\t\t\t          Product* GetProduct() ; \n\t\t\t          protected:\n\t\t\t              virtual Product* CreateProduct();\n\t\t\t          private:\n\t\t\t              Product* _product;\n\t\t\t      };\n\t\t\t        Product* Creator: :GetProduct () {\n\t\t\t            if (.product ==0) {\n\t\t\t                _product = CreateProduct ( ) ;\n\t\t\t        }\n\t\t\t        return _product;\n\t\t\t      }\n\t\t\t  </pre></li>\n\t\t\t     <li><i>использование шаблонов, чтобы не порождать подклассы.</i> К сожалению, допустима ситуация, когда вам придется порождать подклассы только для того, \n\t\t\t     чтобы создать подходящие объекты-продукты. В C++ этого можно избежать, предоставив шаблонный подкласс класса Creator, параметризованный классом Product:\n\t\t\t <pre>\n\t\t\t     class Creator { \n\t\t\t     public:\n\t\t\t        virtual Product* CreateProduct () = 0;\n\t\t\t      };\n\t\t\t      \n\t\t\t      template <class TheProduct>\n\t\t\t      class StandardCreator: public Creator {\n\t\t\t      public:\n\t\t\t      virtual Product* CreateProduct();\n\t\t\t      };\n\t\t\t      \n\t\t\t      template <class TheProduct>\n\t\t\t      Product* StandardCreator<TheProduct>::CreateProduct ()\t{\n\t\t\t          return new TheProduct;\n\t\t\t      }\n\t\t\t </pre>\n\t\t\t      <p>С помощью данного шаблона клиент передает только класс продукта, по¬рождать подклассы от Creator не требуется:</p>\n\t\t\t <pre>\n\t\t\t    class MyProduct : public Product { \n\t\t\t    public:\n\t\t\t        MyProduct() ;\n\t\t\t        // ...\n\t\t\t    };\n\n\t\t\t    StandardCreator<MyProduct> myCreator ;\n\t\t\t  </pre></li>\n\t\t\t      <li><i>соглашения об именовании</i>. На практике рекомендуется применять такие соглашения об именах, которые дают ясно понять, что вы пользуетесь фабричными\n\t\t\t методами. Например, каркас МасАрр на платформе Macintosh [App89] всегда объявляет абстрактную операцию, которая определяет фабричный метод, в виде Class* DoMakeClass ( ),\n\t\t\t где Class - это класс продукта. </li>\n\t\t\t </ul>\n\t\t\t<p><b><i>Пример кода</i></b></p>\n\t\t\t<p>Функция CreateMaze строит и возвращает лабиринт. Одна из связанных с ней проблем состоит в том, что классы лабиринта, комнат, дверей и стен жестко «зашиты» в данной функции. Мы\n\t\t\t введем фабричные методы, которые позволят выбирать эти компоненты подклассам.</p>\n\t\t\t<p>Сначала определим фабричные методы в игре MazeGame для создания объектов лабиринта, комнат, дверей и стен:</p>\n\t\t\t<pre>\n\t\t\t    class MazePrototypeFactory : \n\t\t\t    public:\n\t\t\t    Maze* CreateMaze();\n\t\t\t   \n\t\t\t  // фабричные методы:\n\t\t\t  \n\t\t\t    virtual Maze* MakeMazeO const\n\t\t\t        { return new Maze; }\n\t\t\t    virtual Room* MakeRoom(int n) const \n\t\t\t        { return new Room(n);\t}\n\t\t\t    virtual Wall* MakeWalK) const \n\t\t\t        { return new Wall; }\n\t\t\t    virtual Door* MakeDoor(Room* rl, Room* r2) const \n\t\t\t        { return new Door(rl, r2);\t}\n\t\t\t    };\n\t\t\t</pre>\n\t\t\t<p>Каждый фабричный метод возвращает один из компонентов лабиринта. Класс MazeGame предоставляет реализации по умолчанию, которые возвращают простейшие варианты лабиринта,\n\t\t\t комнаты, двери и стены.</p>\n\t\t\t<p>Теперь мы можем переписать функцию CreateMaze с использованием этих фабричных методов:</p>\n\t\t\t<pre>\n\t\t\t      Maze* MazeGame::CreateMaze ()\t{\n\t\t\t        Maze* aMaze = MakeMaze();\n\t\t\t        \n\t\t\t      Room* rl = MakeRoom(l);\n\t\t\t      Room* r2 = MakeRoom(2) ;\n\t\t\t      Door* theDoor = MakeDoor(rl, r2) ;\n\t\t\t      \n\t\t\t      aMaze->AddRoom(rl); \n\t\t\t      aMaze->AddRoom(r2);\n\t\t\t      \n\t\t\t      rl->SetSide(North, MakeWall());\n\t\t\t      rl->SetSide(East, theDoor);\n\t\t\t      rl->SetSide(South, MakeWall());\n\t\t\t      rl->SetSide(West, MakeWall());\n\t\t\t      \n\t\t\t      r2->SetSide(North, MakeWall());\n\t\t\t      r2->SetSide(East, MakeWall());\n\t\t\t      r2->SetSide(South, MakeWall());\n\t\t\t      r2->SetSide(West, theDoor);\n\t\t\t      \n\t\t\t    return aMaze;\n\t\t\t      }\n\t\t\t </pre>\n\t\t\t<p>В играх могут порождаться различные подклассы MazeGame для специализации частей лабиринта. В этих подклассах допустимо переопределение некоторых или всех методов,\n\t\t\t от которых зависят разновидности продуктов. Например, в игре BombedMazeGame продукты Room и Wall могут быть переопределены так, чтобы возвращать комнату и стену \n\t\t\t с заложенной бомбой:</p>\n\t\t\t<pre>\n\t\t\t    class BombedMazeGame : public MazeGame {\n\t\t\t    public:\n\t\t\t      BombedMazeGame();\n\t\t\t      \n\t\t\t          virtual Wall* MakeWall() const\n\t\t\t                { return new BombedWall; }\n\t\t\t          virtual Room* MakeRoom(int n) const \n\t\t\t                { return new RoomWithABomb(n);\t}\n\t\t\t    };\n\t\t\t</pre>\n\t\t\t<p>А в игре Enchant edMazeGame допустимо определить такие варианты:</p>\n\t\t\t<pre>\n\t\t\t        class EnchantedMazeGame : public MazeGame {\n\t\t\t        public:\n\t\t\t            EnchantedMazeGame();\n\t\t\t            \n\t\t\t              virtual Room* MakeRoomdnt n) const\n\t\t\t                { return new EnchantedRoom(n, CastSpell());\t}\n\t\t\t                \n\t\t\t              virtual Door* MakeDoor(Room* rl, Room* r2) const \n\t\t\t                { return new DoorNeedingSpell(rl, r2); }\n\t\t\t        protected:\n\t\t\t          Spell* CastSpell() const;\n\t\t\t  };\n\t\t\t </pre>\n\t\t\t<p><b><i>Известные применения</i></b></p>\n\t\t\t<p>Фабричные методы в изобилии встречаются в инструментальных библиотеках и каркасах. Рассмотренный выше пример с документами - это типичное применение в каркасе МасАрр \n\t\t\tи библиотеке ЕТ++ [WGM88]. Пример с манипулято¬ром заимствован из каркаса Unidraw.</p>\n\t\t\t<p>Класс View в схеме модель/вид/контроллер из языка Smalltalk-80 имеет ме¬тод defaultController, который создает контроллер, и этот метод выглядит как фабричный \n\t\t\t[РагЭО]. Но подклассы View специфицируют класс своего контроллера по умолчанию, определяя метод def aultControllerClass, возвращающий класс, экземпляры которого\n\t\t\t создает defaultController. Таким образом, реальным фабричным методом является def aultControllerClass, то есть метод, который должен переопределяться в подклассах.</p>\n\t\t\t<p>Более необычным является пример фабричного метода parserClass, тоже взятый из Smalltalk-80, который определяется поведением Behavior (суперкласс всех объектов,\n\t\t\t представляющих классы). Он позволяет классу использовать специализированный анализатор своего исходного кода. Например, клиент может определить класс SQLParser \n\t\t\t для анализа исходного кода класса, содержащего встроенные предложения на языке SQL. Класс Behavior реализует par serClass так, что тот возвращает стандартный \n\t\t\t для Smalltalk класс анализатора Parser. Класс же, включающий предложения SQL, замещает этот метод (как метод класса) и возвращает класс SQLParser.</p>\n\t\t\t<p>Система Orbix ORB от компании IONA Technologies [ION94] использует фабричный метод для генерирования подходящих заместителей (см. паттерн заместитель) \n\t\t\tв случае, когда объект запрашивает ссылку на удаленный объект. Фабричный метод позволяет без труда заменить подразумеваемого заместителя, например таким,\n\t\t\t который применяет кэширование на стороне клиента.</p>\n\t\t\t<p><b><i>Родственные паттерны</i></b></p>\n\t\t\t<p>Абстрактная фабрика часто реализуется с помощью фабричных методов. Пример в разделе «Мотивация» из описания абстрактной фабрики иллюстрирует также и паттерн фабричные методы.</p>\n\t\t\t<p>Паттерн фабричные методы часто вызывается внутри шаблонных методов. В примере с документами NewDocument - это шаблонный метод.</p>\n\t\t\t<p>Прототипы не нуждаются в порождении подклассов от класса Creator. Однако им часто бывает необходима операция Initialize в классе Product. Treator использует\n\t\t\t Initialize для инициализации объекта. Фабричному методу такая операция не требуется.</p>"}},{"id":3,"book":{"data":"asdasdasdasd"}},{"id":4,"book":{"data":"<h3>Паттерн Prototype</h3>\n\t\t\t<p><b><i>Название и классификация паттерна</i></b></p>\n\t\t\t<p>Прототип - паттерн, порождающий объекты.</p>\n\t\t\t<p><b><i>Назначение</i></b></p>\n\t\t\t<p>Задает виды создаваемых объектов с помощью экземпляра-прототипа и создает новые объекты путем копирования этого прототипа.</p>\n\t\t\t<p><b><i>Мотивация</i></b></p>\n\t\t\t<p>Построить музыкальный редактор удалось бы путем адаптации общего каркаса графических редакторов и добавления новых объектов, представляющих ноты, паузы и нотный \n\t\t\tстан. В каркасе редактора может присутствовать палитра инструментов для добавления в партитуру этих музыкальных объектов. Палитра может также содержать\n\t\t\t инструменты для выбора, перемещения и иных манипуляций с объектами. Так, пользователь, щелкнув, например, по значку четверти поместил бы ее тем самым \n\t\t\t в партитуру. Или, применив инструмент перемещения, : двигал бы ноту на стане вверх или вниз, чтобы изменить ее высоту.</p>\n\t\t\t<p>Предположим, что каркас предоставляет абстрактный класс Graphic для графических компонентов вроде нот и нотных станов, а также абстрактный класс \n\t\t\t Tool для определения инструментов в палитре. Кроме того, в каркасе имеется предопределенный подкласс GraphicTool для инструментов, которые создают графические\n\t\t\t объекты и добавляют их в документ.</p>\t\t\t \n\t\t\t<p>Однако класс GraphicTool создает некую проблему для проектировщика каркаса. Классы нот и нотных станов специфичны для нашего приложения, а класс GraphicTool\n\t\t\t принадлежит каркасу. Этому классу ничего неизвестно о том, как создавать экземпляры наших музыкальных классов и добавлять их в партитуру. Можно было бы породить\n\t\t\t от GraphicTool подклассы для каждого вида музыкальных объектов, но тогда оказалось бы слишком много классов, отличающихся только тем, какой музыкальный объект они\n\t\t\t инстанцируют. Мы знаем, что гибкой альтернативой порождению подклассов является композиция. Вопрос в том, как каркас мог бы воспользоваться ею для параметризации\n\t\t\t экземпляров GraphicTool классом того объекта Graphic, который предполагается создать.</p>\n\t\t\t<p>Решение - заставить GraphicTool создавать новый графический объект, копируя или «клонируя» экземпляр подкласса класса Graphic. Этот экземпляр мы будем называть \n\t\t\t<i>прототипом</i>. GraphicTool параметризуется прототипом, который он должен клонировать и добавить в документ. Если все подклассы Graphic поддерживают операцию \n\t\t\tClone, то GraphicTool может клонировать любой вид графических объектов.</p>\n\t\t\t<p>Итак, в нашем музыкальном редакторе каждый инструмент для создания музыкального объекта - это экземпляр класса GraphicTool, инициализированный тем или иным \n\t\t\tпрототипом. Любой экземпляр GraphicTool будет создавать музыкальный объект, клонируя его прототип и добавляя клон в партитуру.</p>\n\t\t\t<p>Можно воспользоваться паттерном прототип, чтобы еще больше сократить число классов. Для целых и половинных нот у нас есть отдельные классы, но,\n\t\t\t быть может, это излишне. Вместо этого они могли бы быть экземплярами одного и того же класса, инициализированного разными растровыми изображениями\n\t\t\t и длительностями звучания. Инструмент для создания целых нот становится просто объектом класса GraphicTool, в котором прототип MusicalNote инициализирован \n\t\t\t целой нотой. Это может значительно уменьшить число классов в системе. Заодно упрощается добавление нового вида нот в музыкальный редактор.</p>\n\t\t\t<p><b><i>Применимость</i></b></p>\n\t\t\t<p>Используйте паттерн прототип, когда система не должна зависеть от того, как в ней создаются, компонуются и представляются продукты:</p>\n\t\t\t  <ul>\n\t\t\t      <li> инстанцируемые классы определяются во время выполнения, например с помощью динамической загрузки;</li>\n\t\t\t      <li>для того чтобы избежать построения иерархий классов или фабрик, параллельных иерархии классов продуктов;</li>\n\t\t\t      <li>а экземпляры класса могут находиться в одном из не очень большого числа различных состояний. Может оказаться удобнее установить соответствующее\n\t\t\t          число прототипов и клонировать их, а не инстанцировать каждый раз класс вручную в подходящем состоянии.</li>\n\t\t\t  </ul>\n\t\t\t<p><b><i>Структура</i></b></p>\t\t\t \n\t\t\t<p><b><i>Участники</i></b></p>\n\t\t\t  <ul>\n\t\t\t      <li><b>Prototype</b> (Graphic) - прототип:\n\t\t\t          <ul>\n\t\t\t              <li>-\tобъявляет интерфейс для клонирования самого себя;</li>\n\t\t\t          </ul></li>\n\t\t\t      <li><b>ConcretePrototype</b> (Staff- нотный стан, WholeNote - целая нота, HalfNote - половинная нота) - конкретный прототип:\n\t\t\t          <ul>\n\t\t\t              <li>-\tреализует операцию клонирования себя; \n\t\t\t          </ul></li>\n\t\t\t      <li><b>Client</b> (GraphicTool) - клиент:\n\t\t\t          <ul>\n\t\t\t              <li>-\tсоздает новый объект, обращаясь к прототипу с запросом клонировать себя.</li>\n\t\t\t          </ul></li>\n\t\t\t  </ul>\n\t\t\t<p><b><i>Отношения</i></b></p>\n\t\t\t<p>Клиент обращается к прототипу, чтобы тот создал свою копию.</p>\n\t\t\t<p><b><i>Результаты</i></b></p>\n\t\t\t<p>У прототипа те же самые результаты, что у абстрактной фабрики и строителя: он скрывает от клиента конкретные классы продуктов, уменьшая тем самым \n\t\t\tчисло известных клиенту имен. Кроме того, все эти паттерны позволяют клиентам работать со специфичными для приложения классами без модификаций.</p>\n\t\t\t<p>Ниже перечислены дополнительные преимущества паттерна прототип:</p>\n\t\t\t<ul>\n\t\t\t    <li><i>добавление и удаление продуктов во время выполнения</i>. Прототип позволяет включать новый конкретный класс\n\t\t\t продуктов в систему, просто сообщив клиенту о новом экземпляре-прототипе. Это несколько более гибкое решение по сравнению с тем, что удастся сделать с помощью других\n\t\t\t порождающих паттернов, ибо клиент может устанавливать и удалять прототипы во время выполнения;</li>\n\t\t\t    <li><i>спецификация новых объектов путем изменения значений</i>. Динамичные системы  позволяют определять поведение за счет композиции объектов - например, \n\t\t\t    путем задания значений переменных объекта, - а не с помощью определения новых классов. По сути дела, вы определяете новые виды объектов, инстанцируя \n\t\t\t    уже существующие классы и регистрируя их-экземпляры как прототипы клиентских объектов. Клиент может изменить поведение,  делегируя свои обязанности прототипу.\n\t\t\t    <p>Такой дизайн позволяет пользователям определять новые классы без программирования. Фактически клонирование объекта аналогично инстанцированию класса. Паттерн прототип \n\t\t\t    может резко уменьшить число необходимых системе классов. В нашем музыкальном редакторе с помощью одного только класса GraphicTool удастся создать бесконечное\n\t\t\t    разнообразие музыкальных объектов; \n\t\t\t    <li> <i>специфицирование новых объектов путем изменения структуры</i>. Многие приложения строят объекты из крупных и мелких составляющих.\n\t\t\t    <p>Например, редакторы для проектирования печатных плат создают электрические схемы из подсхем.1 Такие приложения часто позволяют инстанцировать сложные, \n\t\t\t    определенные пользователем структуры, скажем, для многократного использования некоторой подсхемы.</p>\n\t\t\t    <p>Паттерн прототип поддерживает и такую возможность. Мы просто добавляем подсхему как прототип в палитру доступных элементов схемы. При условии, что объект,\n\t\t\t    представляющий составную схему, реализует операцию Clone как глубокое копирование, схемы с разными структурами могут выступать в качестве прототипов;</li>\n\t\t\t    <li><i>уменьшение числа подклассов</i>. Паттерн фабричный метод часто порождает иерархию классов Creator, параллельную иерархии классов продуктов. Прототип позволяет клонировать\n\t\t\t      прототип, а не запрашивать фабричный метод создать новый объект. Поэтому иерархия класса Creator становится вообще ненужной. Это преимущество касается главным\n\t\t\t      образом языков типа C++, где классы не рассматриваются как настоящие объекты. В языках же типа Smalltalk и Objective С это не так существенно, поскольку всегда можно\n\t\t\t      использовать объект-класс в качестве создателя. В таких языках объекты- классы уже выступают как прототипы;</li>\n\t\t\t    <li><i>динамическое конфигурирование приложения классами</i>. Некоторые среды позволяют динамически загружать классы в приложение во время его выполнения. Паттерн прототип - \n\t\t\t    это ключ к применению таких возможностей в языке типа C++.Для таких приложений характерны паттерны компоновщик и декоратор. \n\t\t\t    <p>Приложение, которое создает экземпляры динамически загружаемого класса, не может обращаться к его конструктору статически. Вместо этого исполняющая\n\t\t\t    среда автоматически создает экземпляр каждого класса в момент его загрузки и регистрирует экземпляр в диспетчере прототипов (см. раздел «Реализация»). Затем\n\t\t\t      приложение может запросить у диспетчера прототипов экземпляры вновь загруженных классов, которые изначально не были связаны с программой. Каркас приложений\n\t\t\t      ЕТ++ [WGM88] в своей исполняющей среде использует именно такую схему.</p></li>\n\t\t\t </ul>\n\t\t\t<p>Основной недостаток паттерна прототип заключается в том, что каждый под- •пасс класса Prototype должен реализовывать операцию Clone, а это далеко\n\t\t\t не всегда просто. Например, сложно добавить операцию Clone, когда рассматрива- тмые классы уже существуют. Проблемы возникают и в случае,\n\t\t\t если во внутреннем представлении объекта есть другие объекты или наличествуют круговые ссылки.</p>\n\t\t\t<p><b><i>Реализация</i></b></p>\n\t\t\t<p>Прототип особенно полезен в статически типизированных языках вроде C++, где классы не являются объектами, а во время выполнения информации\n\t\t\t о типе достаточно или нет вовсе. Меньший интерес данный паттерн представляет для \"аких языков, как Smalltalk или Objective С, в которых и так уже есть нечто\n\t\t\t эквивалентное прототипу (именно - объект-класс) для создания экземпляров каждо- ::» класса. В языки, основанные на прототипах, например Self [US87],\n\t\t\t где создание любого объекта выполняется путем клонирования прототипа, этот паттерн просто встроен.</p>\n\t\t\t<p>Рассмотрим основные вопросы, возникающие при реализации прототипов:</p>\n\t\t\t  <ul>\n\t\t\t    <li>использование диспетчера прототипов. Если число прототипов в системе не фиксировано (то есть они могут создаваться и уничтожаться динамически),\n\t\t\t    ведите реестр доступных прототипов. Клиенты должны не управлять прототипами самостоятельно, а сохранять и извлекать их из реестра. Клиент запрашивает\n\t\t\t    прототип из реестра перед его клонированием. Такой реестр мы будем называть диспетчером прототипов.\n\t\t\t    <p>Диспетчер прототипов - это ассоциативное хранилище, которое возвращает прототип, соответствующий заданному ключу. В нем есть операции для регистрации\n\t\t\t    прототипа с указанным ключом и отмены регистрации. Клиенты могут изменять и даже «просматривать» реестр во время выполнения, а значит, расширять систему\n\t\t\t    и вести контроль над ее состоянием без написания кода;</p></li>\n\t\t\t    <li>реализация операции Clone. Самая трудная часть паттерна прототип - правильная реализация операции Clone. Особенно сложно это в случае, когда в структуре\n\t\t\t      объекта есть круговые ссылки.\n\t\t\t      <p>В большинстве языков имеется некоторая поддержка для клонирования объектов. Например, Smalltalk предоставляет реализацию копирования, которую все подклассы\n\t\t\t      наследуют от класса Object. В C++ есть копирующий конструктор. Но эти средства не решают проблему «глубокого и поверхностного копирования» [GR83]. Суть ее\n\t\t\t      в следующем: должны ли при клонировании объекта клонироваться также и его переменные экземпляра или клон просто разделяет с оригиналом эти переменные?</p>\n\t\t\t      <p>Поверхностное копирование просто, и часто его бывает достаточно. Именно такую возможность и предоставляет по умолчанию Smalltalk. В C++ копирующий конструктор\n\t\t\t      по умолчанию выполняет почленное копирование, . то есть указатели разделяются копией и оригиналом. Но для клонирования прототипов со сложной структурой обычно\n\t\t\t      необходимо глубокое копиро¬вание, поскольку клон должен быть независим от оригинала. Поэтому нужно гарантировать, что компоненты клона являются клонами компонентов\n\t\t\t      прототипа. При клонировании вам приходится решать, что именно может разделяться и может ли вообще.</p>\n\t\t\t      <p>Если объекты в системе предоставляют операции Save (сохранить) и Load (загрузить), то разрешается воспользоваться ими для реализации операции Clone по умолчанию,\n\t\t\t      просто сохранив и сразу же загрузив объект. Операция Save сохраняет объект в буфере памяти, a Load создает дубликат, реконструируя объект из буфера;</p></li>\n\t\t\t    <li> инициализация клонов. Хотя некоторым клиентам вполне достаточно клона как такового, другим нужно инициализировать его внутреннее состояние полностью или\n\t\t\t      частично. Обычно передать начальные значения операции Clone невозможно, поскольку их число различно для разных классов прототипов. Для некоторых прототипов\n\t\t\t      нужно много параметров инициализации, другие вообще ничего не требуют. Передача Clone параметров мешает построению единообразного интерфейса клонирования.\n\t\t\t      <p>Может оказаться, что в ваших классах прототипов уже определяются операции для установки и очистки некоторых важных элементов состояния. Если так, то этими \n\t\t\t      операциями можно воспользоваться сразу после клонирования. В противном случае, возможно, понадобится ввести операцию <b>Initialize</b> (см. раздел «Пример кода»), которая \n\t\t\t      принимает начальные значения в качестве аргументов и соответственно устанавливает внутреннее состояние клона. Будьте осторожны, если операция Clone реализует \n\t\t\t      глубокое копирование: копии может понадобиться удалять (явно или внутри Initialize) перед повторной инициализацией.</p></li>\n\t\t\t  </ul>\n\t\t\t<p><b><i>Пример кода</i></b></p>\n\t\t\t<p>Мы определим подкласс MazePrototypeFactory класса MazeFactory. Этот подкласс будет инициализироваться прототипами объектов, которые ему предстоит создавать, \n\t\t\tпоэтому нам не придется порождать подклассы только ради изменения классов создаваемых стен или комнат.</p>\n\t\t\t<p>MazePrototypeFactory дополняет интерфейс MazeFactory конструктором, принимающим в качестве аргументов прототипы:</p>\n\t\t\t<pre>\n\t\t\t      class MazePrototypeFactory : public MazeFactory {\n\t\t\t      public:\n\t\t\t          MazePrototypeFactory(Maze*, Wall*, Room*, Door*);\n\t\t\t          \n\t\t\t          virtual Maze* MakeMaze() const;\n\t\t\t          virtual Room* MakeRoom(int) const;\n\t\t\t          virtual Wall* MakeWalK) const;\n\t\t\t          virtual Door* MakeDoor(Room*, Room*) const;\n\t\t\t      private:\n\t\t\t          Maze* _prototypeMaze;\n\t\t\t          Room*\tprototypeRoom;\n\t\t\t          Wall* _prototypeWall;\n\t\t\t          Door* _prototypeDoor;\n\t\t\t      };\n\t\t\t </pre>\n\t\t\t<p>Новый конструктор просто инициализирует свои прототипы:</p>\n\t\t\t<pre>\n\t\t\t    MazePrototypeFactory::MazePrototypeFactory (\n\t\t\t      Maze* m, Wall* w, Room* r, Door* d\n\t\t\t    ) {\n\t\t\t        _ prototypeMaze = m;\n\t\t\t        _prototypeWall = w;\n\t\t\t        _prototypeRoom = r;\n\t\t\t        prototypeDoor = d;\n\t\t\t    }\n\t\t\t </pre>\n\t\t\t<p>Функции-члены для создания стен, комнат и дверей похожи друг на друга: каждая клонирует, а затем инициализирует прототип. Вот определения функций ..'akeWall и MakeDoor:</p>\n\t\t\t<pre>\n\t\t\t      Wall* MazePrototypeFactory::MakeWall () const { \n\t\t\t      return _prototypeWall->Clone();\n\t\t\t    }\n\t\t\t      Door* MazePrototypeFactory::MakeDoor (Room* rl, Room *r2) const {\n\t\t\t      Door* door = _prototypeDoor->Clone();\n\t\t\t      door->Initialize(rl, r2);\n\t\t\t      return door;\n\t\t\t  }\n\t\t\t </pre>\n\t\t\t<p>Мы можем применить MazePrototypeFactory для создания прототипичного или принимаемого по умолчанию лабиринта, просто инициализируя его прототипами базовых компонентов:</p>\n\t\t\t<pre>\n\t\t\t    MazeGame game;\n\t\t\t    MazePrototypeFactory simpleMazeFactory( new Maze, new Wall, new Room, new Door\n\t\t\t    );\n\t\t\t    Maze* maze = game.CreateMaze(simpleMazeFactory);\n\t\t\t</pre>\n\t\t\t<p>Для изменения типа лабиринта инициализируем MazePrototypeFactory другим набором прототипов. Следующий вызов создает лабиринт с дверью типа BombedDoor и \n\t\t\tкомнатой типа RoomWithABomb:</p>\n\t\t\t<pre>\n\t\t\t      MazePrototypeFactory bombedMazeFactory( \n\t\t\t        new Maze, new BombedWall, \n\t\t\t        new RoomWithABomb, new Door\n\t\t\t      );\n\t\t\t</pre>      \n\t\t\t<p>Объект, который предполагается использовать в качестве прототипа, напри¬мер экземпляр класса Wall, должен поддерживать операцию Clone. Кроме того. у него должен\n\t\t\t быть копирующий конструктор для клонирования. Также может потребоваться операция для повторной инициализации внутреннего состояния.\n\t\t\t Мы добавим в класс Door операцию Initialize, чтобы дать клиентам возможность инициализировать комнаты клона.</p>\n\t\t\t<p>Сравните следующее определение Door с приведенным на стр. 91:</p>\n\t\t\t<pre>\n\t\t\t      class Door : public MapSite { \n\t\t\t      public:\n\t\t\t        Door () ;\n\t\t\t        Door(const Door&);\n\t\t\t        \n\t\t\t        virtual void Initialize(Room*, Room*);\n\t\t\t        virtual Door* Clone() const;\n\t\t\t        virtual void Enter() ;\n\t\t\t      \n\t\t\t        Room* OtherSideFrom(Room*) ; private:\n\t\t\t        Room* _rooml;\n\t\t\t        Room* _room2;\n\t\t\t      };\n\t\t\t      Door::Door (const Door& other) {\n\t\t\t        _rooml = other._rooml;\n\t\t\t        _room2 = other._room2;\n\t\t\t      }\n\t\t\t      void Door::Initialize (Room* rl, Room* r2)\t{\n\t\t\t        _rooml = rl;\n\t\t\t        _room2 = r2;\n\t\t\t      }\n\t\t\t      Door* Door::Clone () const { \n\t\t\t          return new Door(*this);\n\t\t\t      }\n\t\t\t </pre>\n\t\t\t<p>Подкласс BombedWall должен заместить операцию Clone и реализовать ее ответствующий копирующий конструктор:</p>\n\t\t\t <pre>   \n\t\t\t     class BombedWall : public Wall { \n\t\t\t     public:\n\t\t\t            BombedWall();\n\t\t\t            BombedWall(const BombedWallk);\n\t\t\t            \n\t\t\t            virtual Wall* Clone() const;\n\t\t\t            bool HasBomb(); \n\t\t\t        private:\n\t\t\t            bool _bomb;\n\t\t\t      }; \n\t\t\t      BombedWall::BombedWall (const BombedWallk other) : Wall(other) {\n\t\t\t          _bomb = other._bomb;\n\t\t\t      }\n\t\t\t      Wall* BombedWall::Clone () const { \n\t\t\t            return new BombedWall(*this);\n\t\t\t      }\n\t\t\t  </pre>\n\t\t\t<p>Операция BombedWall: : Clone возвращает Wall*, а ее реализация - указатель на новый экземпляр подкласса, то есть BombedWal 1 *. Мы определяем Clone в базовом \n\t\t\tклассе именно таким образом, чтобы клиентам, клонирующим прототип, не надо было знать о его конкретных подклассах. Клиентам никогда не придется приводить значение,\n\t\t\t возвращаемое Clone, к нужному типу.</p>\n\t\t\t<p>В Smalltalk разрешается использовать стандартный метод копирования, унаследованный от класса Object, для клонирования любого прототипа MapSite. Можно воспользоваться \n\t\t\tфабрикой MazeFactory для изготовления любых необходимых прототипов. Например, допустимо создать комнату по ее номеру #room. В классе MazeFactory есть словарь,\n\t\t\t сопоставляющий именам прототипы. Его метод make: выглядит так:</p>\n\t\t\t<pre>\n\t\t\t    make: partName\n\t\t\t        ^(partCatalog at: partName) copy\n\t\t\t</pre>\n\t\t\t<p>Имея подходящие методы для инициализации MazeFactory прототипами, можно было бы создать простой лабиринт с помощью следующего кода:</p>\n\t\t\t<pre>\n\t\t\t      CreateMaze\n\t\t\t          on:\t(MazeFactory\tnew\n\t\t\t          with: Door new named: #door; \n\t\t\t          with: Wall new named: #wall;\n\t\t\t          with: Room new named: #room;\n\t\t\t          yourself)\n\t\t\t</pre>\n\t\t\t<p>где определение метода класса on: для CreateMaze имеет вид</p>\n\t\t\t <pre>     \n\t\t\t      on: aFactory\n\t\t\t      | rooml room2 |\n\t\t\t      rooml := (aFactory make: #room). location: 1@1.\n\t\t\t      room2 := (aFactory make: #room) location: 2@1. \n\t\t\t      door := (aFactory make: #door) from: rooml to: room2.\n\t\t\t      rooml\n\t\t\t      atSide:#north put:\t(aFactory\tmake:\t#wall)\n\t\t\t      atSide:#east put: door;\n\t\t\t      atSide:#south put:\t(aFactory\tmake:\t#wall)\n\t\t\t      atSide:#west put:\t(aFactory make:\t#wall).\n\t\t\t      room2\n\t\t\t      atSide:#north put:\t(aFactory\tmake:\t#wall)\n\t\t\t      atSide:#east put:\t(aFactory make: #wall);\n\t\t\t      atSide:#south put:\t(aFactory\tmake:\t#wall)\n\t\t\t      atSide:#west put: door. \n\t\t\t      \n\t\t\t     ^А Maze new\n\t\t\t     addRoom: rooml; \n\t\t\t     addRoom: room2;\n\t\t\t     yourself\n\t\t\t</pre>\n\t\t\t<p><b><i>Известные применения</i></b></p>\n\t\t\t<p>Быть может, впервые паттерн прототип был использован в системе Sketchpad Ивана Сазерленда (Ivan Sutherland) [Sut63]. Первым широко известным применением этого\n\t\t\t паттерна в объектно-ориентированном языке была система Thing- Lab, в которой пользователи могли сформировать составной объект, а затем превратить его в прототип, \n\t\t\t поместив в библиотеку повторно используемых объектов [Вог81]. Адель Голдберг и Давид Робсон упоминают прототипы в качестве паттернов в работе [GR83], \n\t\t\t но Джеймс Коплиен [Сор92] рассматривает этот вопрос гораздо шире. Он описывает связанные с прототипом идиомы языка C++ и при¬водит много примеров и вариантов.\n\t\t\tEtgdb - это оболочка отладчиков на базе ЕТ++, где имеется интерфейс вида point-and-click (укажи и щелкни) для различных командных отладчиков. Для каждого из них есть\n\t\t\t свой подкласс DebuggerAdaptor. Например, GdbAdaptor настраивает etgdb на синтаксис команд GNU gdb, a SunDbxAdaptor - на отладчик dbx компании Sun. Набор подклассов \n\t\t\t DebuggerAdaptor не «зашит» в etgdb. Вместо этого он получает имя адаптера из переменной среды, ищет в глобальной таблице прототип с указанным именем, \n\t\t\t а затем его клонирует. Добавить к etgdb новые отладчики можно, связав ядро с подклассом DebuggerAdaptor, разработанным для этого отладчика.</p>\n\t\t\t<p>Библиотека приемов взаимодействия в программе Mode Composer хранит прототипы объектов, поддерживающих различные способы интерактивных отношений [Sha90]. Любой \n\t\t\tсозданный с помощью Mode Composer способ взаимодействия можно применить в качестве прототипа, если поместить его в библиотеку. Паттерн прототип позволяет\n\t\t\t программе поддерживать неограниченное число вариантов отношений.</p>\n\t\t\t<p>Пример музыкального редактора, обсуждавшийся в начале этого раздела, основан на каркасе графических редакторов Unidraw [VL90].</p>\n\t\t\t<p><b><i>Родственные паттерны</i></b></p>\n\t\t\t<p>В некоторых отношениях прототип и абстрактная фабрика являются конкурентами. Но их используют и совместно. Абстрактная фабрика может хранить набор прототипов,\n\t\t\t которые клонируются и возвращают изготовленные объекты.</p>\n\t\t\t<p>В тех проектах, где активно применяются паттерны компоновщик и декоратор, тоже можно извлечь пользу из прототипа.</p>"}}]